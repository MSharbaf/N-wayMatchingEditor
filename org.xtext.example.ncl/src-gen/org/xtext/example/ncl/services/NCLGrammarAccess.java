/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.ncl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.ocl.xtext.base.services.BaseGrammarAccess;
import org.eclipse.ocl.xtext.essentialocl.services.EssentialOCLGrammarAccess;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class NCLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class TopLevelCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.TopLevelCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOwnedImportsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedImportsImportCPParserRuleCall_3_0 = (RuleCall)cOwnedImportsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cRuleKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cOwnedHomocomsAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cOwnedHomocomsHomocomCPParserRuleCall_4_2_0 = (RuleCall)cOwnedHomocomsAssignment_4_2.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cRuleKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Assignment cOwnedHetecomsAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cOwnedHetecomsHetecomCPParserRuleCall_5_2_0 = (RuleCall)cOwnedHetecomsAssignment_5_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//TopLevelCP:
		//	'module' name=Identifier '{'
		//	ownedImports+=ImportCP+ ('rule' UnrestrictedName ownedHomocoms+=HomocomCP)* ('rule' UnrestrictedName
		//	ownedHetecoms+=HetecomCP)*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'module' name=Identifier '{' ownedImports+=ImportCP+ ('rule' UnrestrictedName ownedHomocoms+=HomocomCP)* ('rule'
		//UnrestrictedName ownedHetecoms+=HetecomCP)* '}'
		public Group getGroup() { return cGroup; }
		
		//'module'
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }
		
		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//ownedImports+=ImportCP+
		public Assignment getOwnedImportsAssignment_3() { return cOwnedImportsAssignment_3; }
		
		//ImportCP
		public RuleCall getOwnedImportsImportCPParserRuleCall_3_0() { return cOwnedImportsImportCPParserRuleCall_3_0; }
		
		//('rule' UnrestrictedName ownedHomocoms+=HomocomCP)*
		public Group getGroup_4() { return cGroup_4; }
		
		//'rule'
		public Keyword getRuleKeyword_4_0() { return cRuleKeyword_4_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_4_1() { return cUnrestrictedNameParserRuleCall_4_1; }
		
		//ownedHomocoms+=HomocomCP
		public Assignment getOwnedHomocomsAssignment_4_2() { return cOwnedHomocomsAssignment_4_2; }
		
		//HomocomCP
		public RuleCall getOwnedHomocomsHomocomCPParserRuleCall_4_2_0() { return cOwnedHomocomsHomocomCPParserRuleCall_4_2_0; }
		
		//('rule' UnrestrictedName ownedHetecoms+=HetecomCP)*
		public Group getGroup_5() { return cGroup_5; }
		
		//'rule'
		public Keyword getRuleKeyword_5_0() { return cRuleKeyword_5_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_5_1() { return cUnrestrictedNameParserRuleCall_5_1; }
		
		//ownedHetecoms+=HetecomCP
		public Assignment getOwnedHetecomsAssignment_5_2() { return cOwnedHetecomsAssignment_5_2; }
		
		//HetecomCP
		public RuleCall getOwnedHetecomsHetecomCPParserRuleCall_5_2_0() { return cOwnedHetecomsHetecomCPParserRuleCall_5_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ImportCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.ImportCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNameIdentifierParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOwnedPathNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedPathNameURIPathNameCSParserRuleCall_2_0 = (RuleCall)cOwnedPathNameAssignment_2.eContents().get(0);
		private final Assignment cIsAllAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cIsAllColonColonAsteriskKeyword_3_0 = (Keyword)cIsAllAssignment_3.eContents().get(0);
		
		//ImportCP base::ImportCS:
		//	'import' (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//(name=Identifier ':')?
		public Group getGroup_1() { return cGroup_1; }
		
		//name=Identifier
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0_0() { return cNameIdentifierParserRuleCall_1_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//ownedPathName=URIPathNameCS
		public Assignment getOwnedPathNameAssignment_2() { return cOwnedPathNameAssignment_2; }
		
		//URIPathNameCS
		public RuleCall getOwnedPathNameURIPathNameCSParserRuleCall_2_0() { return cOwnedPathNameURIPathNameCSParserRuleCall_2_0; }
		
		//isAll?='::*'?
		public Assignment getIsAllAssignment_3() { return cIsAllAssignment_3; }
		
		//'::*'
		public Keyword getIsAllColonColonAsteriskKeyword_3_0() { return cIsAllColonColonAsteriskKeyword_3_0; }
	}
	public class HomocomCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HomocomCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchHomoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOwnedMetaModelsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOwnedMetaModelsMetaModelTypeCSParserRuleCall_1_0 = (RuleCall)cOwnedMetaModelsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cExtendsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_2_2_1 = (RuleCall)cGroup_2_2.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cCompareModelsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOwnedStatementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOwnedStatementsHomoStatementCSParserRuleCall_6_0 = (RuleCall)cOwnedStatementsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//HomocomCP:
		//	'matchHomo' ownedMetaModels+=metaModelTypeCS ('extends' UnrestrictedName (',' UnrestrictedName)*)?
		//	'{'
		//	'compareModels' ':' ownedStatements+=HomoStatementCS+
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'matchHomo' ownedMetaModels+=metaModelTypeCS ('extends' UnrestrictedName (',' UnrestrictedName)*)? '{' 'compareModels'
		//':' ownedStatements+=HomoStatementCS+ '}'
		public Group getGroup() { return cGroup; }
		
		//'matchHomo'
		public Keyword getMatchHomoKeyword_0() { return cMatchHomoKeyword_0; }
		
		//ownedMetaModels+=metaModelTypeCS
		public Assignment getOwnedMetaModelsAssignment_1() { return cOwnedMetaModelsAssignment_1; }
		
		//metaModelTypeCS
		public RuleCall getOwnedMetaModelsMetaModelTypeCSParserRuleCall_1_0() { return cOwnedMetaModelsMetaModelTypeCSParserRuleCall_1_0; }
		
		//('extends' UnrestrictedName (',' UnrestrictedName)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'extends'
		public Keyword getExtendsKeyword_2_0() { return cExtendsKeyword_2_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_2_1() { return cUnrestrictedNameParserRuleCall_2_1; }
		
		//(',' UnrestrictedName)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_2_2_1() { return cUnrestrictedNameParserRuleCall_2_2_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'compareModels'
		public Keyword getCompareModelsKeyword_4() { return cCompareModelsKeyword_4; }
		
		//':'
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//ownedStatements+=HomoStatementCS+
		public Assignment getOwnedStatementsAssignment_6() { return cOwnedStatementsAssignment_6; }
		
		//HomoStatementCS
		public RuleCall getOwnedStatementsHomoStatementCSParserRuleCall_6_0() { return cOwnedStatementsHomoStatementCSParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class MetaModelTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.metaModelTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cUnrestrictedNameParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//metaModelTypeCS:
		//	name=Identifier ':' UnrestrictedName;
		@Override public ParserRule getRule() { return rule; }
		
		//name=Identifier ':' UnrestrictedName
		public Group getGroup() { return cGroup; }
		
		//name=Identifier
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_0_0() { return cNameIdentifierParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_2() { return cUnrestrictedNameParserRuleCall_2; }
	}
	public class HomoStatementCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HomoStatementCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cAndKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cOwnedConditionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedConditionsHomoConditionCSParserRuleCall_1_1_0 = (RuleCall)cOwnedConditionsAssignment_1_1.eContents().get(0);
		
		//HomoStatementCS:
		//	'not'? (('or' | 'and')? ownedConditions+=HomoConditionCS)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'not'? (('or' | 'and')? ownedConditions+=HomoConditionCS)+
		public Group getGroup() { return cGroup; }
		
		//'not'?
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }
		
		//(('or' | 'and')? ownedConditions+=HomoConditionCS)+
		public Group getGroup_1() { return cGroup_1; }
		
		//('or' | 'and')?
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_0_0() { return cOrKeyword_1_0_0; }
		
		//'and'
		public Keyword getAndKeyword_1_0_1() { return cAndKeyword_1_0_1; }
		
		//ownedConditions+=HomoConditionCS
		public Assignment getOwnedConditionsAssignment_1_1() { return cOwnedConditionsAssignment_1_1; }
		
		//HomoConditionCS
		public RuleCall getOwnedConditionsHomoConditionCSParserRuleCall_1_1_0() { return cOwnedConditionsHomoConditionCSParserRuleCall_1_1_0; }
	}
	public class HomoConditionCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HomoConditionCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cIsValidKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cOwnedElementAAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOwnedElementAFQNParserRuleCall_0_2_0 = (RuleCall)cOwnedElementAAssignment_0_2.eContents().get(0);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_0_3_0 = (Keyword)cAlternatives_0_3.eContents().get(0);
		private final Keyword cLessThanSignKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0_3_2 = (Keyword)cAlternatives_0_3.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_0_3_3 = (Keyword)cAlternatives_0_3.eContents().get(3);
		private final Keyword cExclamationMarkKeyword_0_3_4 = (Keyword)cAlternatives_0_3.eContents().get(4);
		private final Keyword cGreaterThanSignEqualsSignKeyword_0_3_5 = (Keyword)cAlternatives_0_3.eContents().get(5);
		private final Keyword cEqualsSignLessThanSignKeyword_0_3_6 = (Keyword)cAlternatives_0_3.eContents().get(6);
		private final Keyword cINKeyword_0_3_7 = (Keyword)cAlternatives_0_3.eContents().get(7);
		private final Keyword cNotINKeyword_0_3_8 = (Keyword)cAlternatives_0_3.eContents().get(8);
		private final Assignment cOwnedElementBAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cOwnedElementBFQNParserRuleCall_0_4_0 = (RuleCall)cOwnedElementBAssignment_0_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cIsEqualKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cIsTrueKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Keyword cIsFalseKeyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cIsEmptyKeyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Keyword cIsContainKeyword_1_0_4 = (Keyword)cAlternatives_1_0.eContents().get(4);
		private final Keyword cIsEquivalentKeyword_1_0_5 = (Keyword)cAlternatives_1_0.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOwnedElementAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_2_0 = (RuleCall)cOwnedElementAssignment_1_2.eContents().get(0);
		private final Keyword cColonColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cOwnedElementAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_4_0 = (RuleCall)cOwnedElementAssignment_1_4.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cGroup_1.eContents().get(5);
		private final Keyword cFullStopKeyword_1_5_0 = (Keyword)cGroup_1_5.eContents().get(0);
		private final Assignment cOwnedElementAssignment_1_5_1 = (Assignment)cGroup_1_5.eContents().get(1);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_5_1_0 = (RuleCall)cOwnedElementAssignment_1_5_1.eContents().get(0);
		private final Group cGroup_1_5_2 = (Group)cGroup_1_5.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1_5_2_0 = (Keyword)cGroup_1_5_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_5_2_1 = (Keyword)cGroup_1_5_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		
		//HomoConditionCS:
		//	'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
		//	('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//	ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
		//('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'isValid'
		public Keyword getIsValidKeyword_0_0() { return cIsValidKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//ownedElementA=FQN
		public Assignment getOwnedElementAAssignment_0_2() { return cOwnedElementAAssignment_0_2; }
		
		//FQN
		public RuleCall getOwnedElementAFQNParserRuleCall_0_2_0() { return cOwnedElementAFQNParserRuleCall_0_2_0; }
		
		//'>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN'
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0_3_0() { return cGreaterThanSignKeyword_0_3_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0_3_1() { return cLessThanSignKeyword_0_3_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_3_2() { return cEqualsSignKeyword_0_3_2; }
		
		//'<>'
		public Keyword getLessThanSignGreaterThanSignKeyword_0_3_3() { return cLessThanSignGreaterThanSignKeyword_0_3_3; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0_3_4() { return cExclamationMarkKeyword_0_3_4; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_0_3_5() { return cGreaterThanSignEqualsSignKeyword_0_3_5; }
		
		//'=<'
		public Keyword getEqualsSignLessThanSignKeyword_0_3_6() { return cEqualsSignLessThanSignKeyword_0_3_6; }
		
		//'IN'
		public Keyword getINKeyword_0_3_7() { return cINKeyword_0_3_7; }
		
		//'NotIN'
		public Keyword getNotINKeyword_0_3_8() { return cNotINKeyword_0_3_8; }
		
		//ownedElementB=FQN
		public Assignment getOwnedElementBAssignment_0_4() { return cOwnedElementBAssignment_0_4; }
		
		//FQN
		public RuleCall getOwnedElementBFQNParserRuleCall_0_4_0() { return cOwnedElementBFQNParserRuleCall_0_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_5() { return cRightParenthesisKeyword_0_5; }
		
		//('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'isEqual'
		public Keyword getIsEqualKeyword_1_0_0() { return cIsEqualKeyword_1_0_0; }
		
		//'isTrue'
		public Keyword getIsTrueKeyword_1_0_1() { return cIsTrueKeyword_1_0_1; }
		
		//'isFalse'
		public Keyword getIsFalseKeyword_1_0_2() { return cIsFalseKeyword_1_0_2; }
		
		//'isEmpty'
		public Keyword getIsEmptyKeyword_1_0_3() { return cIsEmptyKeyword_1_0_3; }
		
		//'isContain'
		public Keyword getIsContainKeyword_1_0_4() { return cIsContainKeyword_1_0_4; }
		
		//'isEquivalent'
		public Keyword getIsEquivalentKeyword_1_0_5() { return cIsEquivalentKeyword_1_0_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_2() { return cOwnedElementAssignment_1_2; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_2_0() { return cOwnedElementFQNParserRuleCall_1_2_0; }
		
		//'::'
		public Keyword getColonColonKeyword_1_3() { return cColonColonKeyword_1_3; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_4() { return cOwnedElementAssignment_1_4; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_4_0() { return cOwnedElementFQNParserRuleCall_1_4_0; }
		
		//("." ownedElement+=FQN ('(' ')')?)*
		public Group getGroup_1_5() { return cGroup_1_5; }
		
		//"."
		public Keyword getFullStopKeyword_1_5_0() { return cFullStopKeyword_1_5_0; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_5_1() { return cOwnedElementAssignment_1_5_1; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_5_1_0() { return cOwnedElementFQNParserRuleCall_1_5_1_0; }
		
		//('(' ')')?
		public Group getGroup_1_5_2() { return cGroup_1_5_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_5_2_0() { return cLeftParenthesisKeyword_1_5_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_5_2_1() { return cRightParenthesisKeyword_1_5_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_6() { return cRightParenthesisKeyword_1_6; }
	}
	public class HetecomCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HetecomCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMatchHeteKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOwnedModelsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOwnedModelsMetaModelTypeCSParserRuleCall_1_0 = (RuleCall)cOwnedModelsAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOwnedModelsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedModelsMetaModelTypeCSParserRuleCall_3_0 = (RuleCall)cOwnedModelsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOwnedModelsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cOwnedModelsMetaModelTypeCSParserRuleCall_4_1_0 = (RuleCall)cOwnedModelsAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cExtendsKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Group cGroup_5_2 = (Group)cGroup_5.eContents().get(2);
		private final Keyword cCommaKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_5_2_1 = (RuleCall)cGroup_5_2.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cCompareModelsKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cColonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cOwnedStatementsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cOwnedStatementsHeteStatementCSParserRuleCall_9_0 = (RuleCall)cOwnedStatementsAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//HetecomCP:
		//	'matchHete' ownedModels+=metaModelTypeCS
		//	'with' ownedModels+=metaModelTypeCS (',' ownedModels+=metaModelTypeCS)* ('extends' UnrestrictedName (','
		//	UnrestrictedName)*)?
		//	'{'
		//	'compareModels' ':' ownedStatements+=HeteStatementCS+
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'matchHete' ownedModels+=metaModelTypeCS 'with' ownedModels+=metaModelTypeCS (',' ownedModels+=metaModelTypeCS)*
		//('extends' UnrestrictedName (',' UnrestrictedName)*)? '{' 'compareModels' ':' ownedStatements+=HeteStatementCS+ '}'
		public Group getGroup() { return cGroup; }
		
		//'matchHete'
		public Keyword getMatchHeteKeyword_0() { return cMatchHeteKeyword_0; }
		
		//ownedModels+=metaModelTypeCS
		public Assignment getOwnedModelsAssignment_1() { return cOwnedModelsAssignment_1; }
		
		//metaModelTypeCS
		public RuleCall getOwnedModelsMetaModelTypeCSParserRuleCall_1_0() { return cOwnedModelsMetaModelTypeCSParserRuleCall_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
		
		//ownedModels+=metaModelTypeCS
		public Assignment getOwnedModelsAssignment_3() { return cOwnedModelsAssignment_3; }
		
		//metaModelTypeCS
		public RuleCall getOwnedModelsMetaModelTypeCSParserRuleCall_3_0() { return cOwnedModelsMetaModelTypeCSParserRuleCall_3_0; }
		
		//(',' ownedModels+=metaModelTypeCS)*
		public Group getGroup_4() { return cGroup_4; }
		
		//','
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }
		
		//ownedModels+=metaModelTypeCS
		public Assignment getOwnedModelsAssignment_4_1() { return cOwnedModelsAssignment_4_1; }
		
		//metaModelTypeCS
		public RuleCall getOwnedModelsMetaModelTypeCSParserRuleCall_4_1_0() { return cOwnedModelsMetaModelTypeCSParserRuleCall_4_1_0; }
		
		//('extends' UnrestrictedName (',' UnrestrictedName)*)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'extends'
		public Keyword getExtendsKeyword_5_0() { return cExtendsKeyword_5_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_5_1() { return cUnrestrictedNameParserRuleCall_5_1; }
		
		//(',' UnrestrictedName)*
		public Group getGroup_5_2() { return cGroup_5_2; }
		
		//','
		public Keyword getCommaKeyword_5_2_0() { return cCommaKeyword_5_2_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_5_2_1() { return cUnrestrictedNameParserRuleCall_5_2_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }
		
		//'compareModels'
		public Keyword getCompareModelsKeyword_7() { return cCompareModelsKeyword_7; }
		
		//':'
		public Keyword getColonKeyword_8() { return cColonKeyword_8; }
		
		//ownedStatements+=HeteStatementCS+
		public Assignment getOwnedStatementsAssignment_9() { return cOwnedStatementsAssignment_9; }
		
		//HeteStatementCS
		public RuleCall getOwnedStatementsHeteStatementCSParserRuleCall_9_0() { return cOwnedStatementsHeteStatementCSParserRuleCall_9_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}
	public class HeteStatementCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HeteStatementCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cAndKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cOwnedConditionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOwnedConditionsHeteConditionCSParserRuleCall_1_1_0 = (RuleCall)cOwnedConditionsAssignment_1_1.eContents().get(0);
		
		//HeteStatementCS:
		//	'not'? (('or' | 'and')? ownedConditions+=HeteConditionCS)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'not'? (('or' | 'and')? ownedConditions+=HeteConditionCS)+
		public Group getGroup() { return cGroup; }
		
		//'not'?
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }
		
		//(('or' | 'and')? ownedConditions+=HeteConditionCS)+
		public Group getGroup_1() { return cGroup_1; }
		
		//('or' | 'and')?
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_0_0() { return cOrKeyword_1_0_0; }
		
		//'and'
		public Keyword getAndKeyword_1_0_1() { return cAndKeyword_1_0_1; }
		
		//ownedConditions+=HeteConditionCS
		public Assignment getOwnedConditionsAssignment_1_1() { return cOwnedConditionsAssignment_1_1; }
		
		//HeteConditionCS
		public RuleCall getOwnedConditionsHeteConditionCSParserRuleCall_1_1_0() { return cOwnedConditionsHeteConditionCSParserRuleCall_1_1_0; }
	}
	public class HeteConditionCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.HeteConditionCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cIsValidKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cOwnedElementAAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOwnedElementAFQNParserRuleCall_0_2_0 = (RuleCall)cOwnedElementAAssignment_0_2.eContents().get(0);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Keyword cGreaterThanSignKeyword_0_3_0 = (Keyword)cAlternatives_0_3.eContents().get(0);
		private final Keyword cLessThanSignKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0_3_2 = (Keyword)cAlternatives_0_3.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_0_3_3 = (Keyword)cAlternatives_0_3.eContents().get(3);
		private final Keyword cExclamationMarkKeyword_0_3_4 = (Keyword)cAlternatives_0_3.eContents().get(4);
		private final Keyword cGreaterThanSignEqualsSignKeyword_0_3_5 = (Keyword)cAlternatives_0_3.eContents().get(5);
		private final Keyword cEqualsSignLessThanSignKeyword_0_3_6 = (Keyword)cAlternatives_0_3.eContents().get(6);
		private final Keyword cINKeyword_0_3_7 = (Keyword)cAlternatives_0_3.eContents().get(7);
		private final Keyword cNotINKeyword_0_3_8 = (Keyword)cAlternatives_0_3.eContents().get(8);
		private final Assignment cOwnedElementBAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cOwnedElementBFQNParserRuleCall_0_4_0 = (RuleCall)cOwnedElementBAssignment_0_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cIsEqualKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cIsTrueKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Keyword cIsFalseKeyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cIsEmptyKeyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Keyword cIsContainKeyword_1_0_4 = (Keyword)cAlternatives_1_0.eContents().get(4);
		private final Keyword cIsEquivalentKeyword_1_0_5 = (Keyword)cAlternatives_1_0.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOwnedElementAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_2_0 = (RuleCall)cOwnedElementAssignment_1_2.eContents().get(0);
		private final Keyword cColonColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cOwnedElementAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_4_0 = (RuleCall)cOwnedElementAssignment_1_4.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cGroup_1.eContents().get(5);
		private final Keyword cFullStopKeyword_1_5_0 = (Keyword)cGroup_1_5.eContents().get(0);
		private final Assignment cOwnedElementAssignment_1_5_1 = (Assignment)cGroup_1_5.eContents().get(1);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_5_1_0 = (RuleCall)cOwnedElementAssignment_1_5_1.eContents().get(0);
		private final Group cGroup_1_5_2 = (Group)cGroup_1_5.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1_5_2_0 = (Keyword)cGroup_1_5_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_5_2_1 = (Keyword)cGroup_1_5_2.eContents().get(1);
		private final Group cGroup_1_6 = (Group)cGroup_1.eContents().get(6);
		private final Keyword cCommaKeyword_1_6_0 = (Keyword)cGroup_1_6.eContents().get(0);
		private final Assignment cOwnedElementAssignment_1_6_1 = (Assignment)cGroup_1_6.eContents().get(1);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_6_1_0 = (RuleCall)cOwnedElementAssignment_1_6_1.eContents().get(0);
		private final Keyword cColonColonKeyword_1_6_2 = (Keyword)cGroup_1_6.eContents().get(2);
		private final Assignment cOwnedElementAssignment_1_6_3 = (Assignment)cGroup_1_6.eContents().get(3);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_6_3_0 = (RuleCall)cOwnedElementAssignment_1_6_3.eContents().get(0);
		private final Group cGroup_1_6_4 = (Group)cGroup_1_6.eContents().get(4);
		private final Keyword cFullStopKeyword_1_6_4_0 = (Keyword)cGroup_1_6_4.eContents().get(0);
		private final Assignment cOwnedElementAssignment_1_6_4_1 = (Assignment)cGroup_1_6_4.eContents().get(1);
		private final RuleCall cOwnedElementFQNParserRuleCall_1_6_4_1_0 = (RuleCall)cOwnedElementAssignment_1_6_4_1.eContents().get(0);
		private final Group cGroup_1_6_4_2 = (Group)cGroup_1_6_4.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1_6_4_2_0 = (Keyword)cGroup_1_6_4_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_6_4_2_1 = (Keyword)cGroup_1_6_4_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		
		//HeteConditionCS:
		//	'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
		//	('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//	ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* (',' ownedElement+=FQN '::' ownedElement+=FQN ("."
		//	ownedElement+=FQN ('(' ')')?)*)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
		//('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* (',' ownedElement+=FQN '::' ownedElement+=FQN ("."
		//ownedElement+=FQN ('(' ')')?)*)* ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'isValid'
		public Keyword getIsValidKeyword_0_0() { return cIsValidKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//ownedElementA=FQN
		public Assignment getOwnedElementAAssignment_0_2() { return cOwnedElementAAssignment_0_2; }
		
		//FQN
		public RuleCall getOwnedElementAFQNParserRuleCall_0_2_0() { return cOwnedElementAFQNParserRuleCall_0_2_0; }
		
		//'>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN'
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0_3_0() { return cGreaterThanSignKeyword_0_3_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0_3_1() { return cLessThanSignKeyword_0_3_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_3_2() { return cEqualsSignKeyword_0_3_2; }
		
		//'<>'
		public Keyword getLessThanSignGreaterThanSignKeyword_0_3_3() { return cLessThanSignGreaterThanSignKeyword_0_3_3; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0_3_4() { return cExclamationMarkKeyword_0_3_4; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_0_3_5() { return cGreaterThanSignEqualsSignKeyword_0_3_5; }
		
		//'=<'
		public Keyword getEqualsSignLessThanSignKeyword_0_3_6() { return cEqualsSignLessThanSignKeyword_0_3_6; }
		
		//'IN'
		public Keyword getINKeyword_0_3_7() { return cINKeyword_0_3_7; }
		
		//'NotIN'
		public Keyword getNotINKeyword_0_3_8() { return cNotINKeyword_0_3_8; }
		
		//ownedElementB=FQN
		public Assignment getOwnedElementBAssignment_0_4() { return cOwnedElementBAssignment_0_4; }
		
		//FQN
		public RuleCall getOwnedElementBFQNParserRuleCall_0_4_0() { return cOwnedElementBFQNParserRuleCall_0_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_5() { return cRightParenthesisKeyword_0_5; }
		
		//('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
		//ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* (',' ownedElement+=FQN '::' ownedElement+=FQN ("."
		//ownedElement+=FQN ('(' ')')?)*)* ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'isEqual'
		public Keyword getIsEqualKeyword_1_0_0() { return cIsEqualKeyword_1_0_0; }
		
		//'isTrue'
		public Keyword getIsTrueKeyword_1_0_1() { return cIsTrueKeyword_1_0_1; }
		
		//'isFalse'
		public Keyword getIsFalseKeyword_1_0_2() { return cIsFalseKeyword_1_0_2; }
		
		//'isEmpty'
		public Keyword getIsEmptyKeyword_1_0_3() { return cIsEmptyKeyword_1_0_3; }
		
		//'isContain'
		public Keyword getIsContainKeyword_1_0_4() { return cIsContainKeyword_1_0_4; }
		
		//'isEquivalent'
		public Keyword getIsEquivalentKeyword_1_0_5() { return cIsEquivalentKeyword_1_0_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_2() { return cOwnedElementAssignment_1_2; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_2_0() { return cOwnedElementFQNParserRuleCall_1_2_0; }
		
		//'::'
		public Keyword getColonColonKeyword_1_3() { return cColonColonKeyword_1_3; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_4() { return cOwnedElementAssignment_1_4; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_4_0() { return cOwnedElementFQNParserRuleCall_1_4_0; }
		
		//("." ownedElement+=FQN ('(' ')')?)*
		public Group getGroup_1_5() { return cGroup_1_5; }
		
		//"."
		public Keyword getFullStopKeyword_1_5_0() { return cFullStopKeyword_1_5_0; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_5_1() { return cOwnedElementAssignment_1_5_1; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_5_1_0() { return cOwnedElementFQNParserRuleCall_1_5_1_0; }
		
		//('(' ')')?
		public Group getGroup_1_5_2() { return cGroup_1_5_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_5_2_0() { return cLeftParenthesisKeyword_1_5_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_5_2_1() { return cRightParenthesisKeyword_1_5_2_1; }
		
		//(',' ownedElement+=FQN '::' ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)*)*
		public Group getGroup_1_6() { return cGroup_1_6; }
		
		//','
		public Keyword getCommaKeyword_1_6_0() { return cCommaKeyword_1_6_0; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_6_1() { return cOwnedElementAssignment_1_6_1; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_6_1_0() { return cOwnedElementFQNParserRuleCall_1_6_1_0; }
		
		//'::'
		public Keyword getColonColonKeyword_1_6_2() { return cColonColonKeyword_1_6_2; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_6_3() { return cOwnedElementAssignment_1_6_3; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_6_3_0() { return cOwnedElementFQNParserRuleCall_1_6_3_0; }
		
		//("." ownedElement+=FQN ('(' ')')?)*
		public Group getGroup_1_6_4() { return cGroup_1_6_4; }
		
		//"."
		public Keyword getFullStopKeyword_1_6_4_0() { return cFullStopKeyword_1_6_4_0; }
		
		//ownedElement+=FQN
		public Assignment getOwnedElementAssignment_1_6_4_1() { return cOwnedElementAssignment_1_6_4_1; }
		
		//FQN
		public RuleCall getOwnedElementFQNParserRuleCall_1_6_4_1_0() { return cOwnedElementFQNParserRuleCall_1_6_4_1_0; }
		
		//('(' ')')?
		public Group getGroup_1_6_4_2() { return cGroup_1_6_4_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_6_4_2_0() { return cLeftParenthesisKeyword_1_6_4_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_6_4_2_1() { return cRightParenthesisKeyword_1_6_4_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_7() { return cRightParenthesisKeyword_1_7; }
	}
	public class FQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.FQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cUnrestrictedNameParserRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cIDParserRuleCall_1_1_1 = (RuleCall)cAlternatives_1_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//FQN:
		//	(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*
		public Group getGroup() { return cGroup; }
		
		//UnrestrictedName | ID
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_0_0() { return cUnrestrictedNameParserRuleCall_0_0; }
		
		//ID
		public RuleCall getIDParserRuleCall_0_1() { return cIDParserRuleCall_0_1; }
		
		//(("." | "->") (UnrestrictedName | ID) '('? ')'?)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"." | "->"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//"."
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }
		
		//UnrestrictedName | ID
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_1_1_0() { return cUnrestrictedNameParserRuleCall_1_1_0; }
		
		//ID
		public RuleCall getIDParserRuleCall_1_1_1() { return cIDParserRuleCall_1_1_1; }
		
		//'('?
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//')'?
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	
	
	private final TopLevelCPElements pTopLevelCP;
	private final ImportCPElements pImportCP;
	private final HomocomCPElements pHomocomCP;
	private final MetaModelTypeCSElements pMetaModelTypeCS;
	private final HomoStatementCSElements pHomoStatementCS;
	private final HomoConditionCSElements pHomoConditionCS;
	private final HetecomCPElements pHetecomCP;
	private final HeteStatementCSElements pHeteStatementCS;
	private final HeteConditionCSElements pHeteConditionCS;
	private final FQNElements pFQN;
	private final TerminalRule tSTRING;
	
	private final Grammar grammar;
	
	private final EssentialOCLGrammarAccess gaEssentialOCL;
	
	private final BaseGrammarAccess gaBase;

	@Inject
	public NCLGrammarAccess(GrammarProvider grammarProvider,
			EssentialOCLGrammarAccess gaEssentialOCL,
			BaseGrammarAccess gaBase) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaEssentialOCL = gaEssentialOCL;
		this.gaBase = gaBase;
		this.pTopLevelCP = new TopLevelCPElements();
		this.pImportCP = new ImportCPElements();
		this.pHomocomCP = new HomocomCPElements();
		this.pMetaModelTypeCS = new MetaModelTypeCSElements();
		this.pHomoStatementCS = new HomoStatementCSElements();
		this.pHomoConditionCS = new HomoConditionCSElements();
		this.pHetecomCP = new HetecomCPElements();
		this.pHeteStatementCS = new HeteStatementCSElements();
		this.pHeteConditionCS = new HeteConditionCSElements();
		this.pFQN = new FQNElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.ncl.NCL.STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.ncl.NCL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public EssentialOCLGrammarAccess getEssentialOCLGrammarAccess() {
		return gaEssentialOCL;
	}
	
	public BaseGrammarAccess getBaseGrammarAccess() {
		return gaBase;
	}

	
	//TopLevelCP:
	//	'module' name=Identifier '{'
	//	ownedImports+=ImportCP+ ('rule' UnrestrictedName ownedHomocoms+=HomocomCP)* ('rule' UnrestrictedName
	//	ownedHetecoms+=HetecomCP)*
	//	'}';
	public TopLevelCPElements getTopLevelCPAccess() {
		return pTopLevelCP;
	}
	
	public ParserRule getTopLevelCPRule() {
		return getTopLevelCPAccess().getRule();
	}
	
	//ImportCP base::ImportCS:
	//	'import' (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?;
	public ImportCPElements getImportCPAccess() {
		return pImportCP;
	}
	
	public ParserRule getImportCPRule() {
		return getImportCPAccess().getRule();
	}
	
	//HomocomCP:
	//	'matchHomo' ownedMetaModels+=metaModelTypeCS ('extends' UnrestrictedName (',' UnrestrictedName)*)?
	//	'{'
	//	'compareModels' ':' ownedStatements+=HomoStatementCS+
	//	'}';
	public HomocomCPElements getHomocomCPAccess() {
		return pHomocomCP;
	}
	
	public ParserRule getHomocomCPRule() {
		return getHomocomCPAccess().getRule();
	}
	
	//metaModelTypeCS:
	//	name=Identifier ':' UnrestrictedName;
	public MetaModelTypeCSElements getMetaModelTypeCSAccess() {
		return pMetaModelTypeCS;
	}
	
	public ParserRule getMetaModelTypeCSRule() {
		return getMetaModelTypeCSAccess().getRule();
	}
	
	//HomoStatementCS:
	//	'not'? (('or' | 'and')? ownedConditions+=HomoConditionCS)+;
	public HomoStatementCSElements getHomoStatementCSAccess() {
		return pHomoStatementCS;
	}
	
	public ParserRule getHomoStatementCSRule() {
		return getHomoStatementCSAccess().getRule();
	}
	
	//HomoConditionCS:
	//	'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
	//	('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
	//	ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* ')';
	public HomoConditionCSElements getHomoConditionCSAccess() {
		return pHomoConditionCS;
	}
	
	public ParserRule getHomoConditionCSRule() {
		return getHomoConditionCSAccess().getRule();
	}
	
	//HetecomCP:
	//	'matchHete' ownedModels+=metaModelTypeCS
	//	'with' ownedModels+=metaModelTypeCS (',' ownedModels+=metaModelTypeCS)* ('extends' UnrestrictedName (','
	//	UnrestrictedName)*)?
	//	'{'
	//	'compareModels' ':' ownedStatements+=HeteStatementCS+
	//	'}';
	public HetecomCPElements getHetecomCPAccess() {
		return pHetecomCP;
	}
	
	public ParserRule getHetecomCPRule() {
		return getHetecomCPAccess().getRule();
	}
	
	//HeteStatementCS:
	//	'not'? (('or' | 'and')? ownedConditions+=HeteConditionCS)+;
	public HeteStatementCSElements getHeteStatementCSAccess() {
		return pHeteStatementCS;
	}
	
	public ParserRule getHeteStatementCSRule() {
		return getHeteStatementCSAccess().getRule();
	}
	
	//HeteConditionCS:
	//	'isValid' '(' ownedElementA=FQN ('>' | '<' | '=' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN') ownedElementB=FQN ')' |
	//	('isEqual' | 'isTrue' | 'isFalse' | 'isEmpty' | 'isContain' | 'isEquivalent') '(' ownedElement+=FQN '::'
	//	ownedElement+=FQN ("." ownedElement+=FQN ('(' ')')?)* (',' ownedElement+=FQN '::' ownedElement+=FQN ("."
	//	ownedElement+=FQN ('(' ')')?)*)* ')';
	public HeteConditionCSElements getHeteConditionCSAccess() {
		return pHeteConditionCS;
	}
	
	public ParserRule getHeteConditionCSRule() {
		return getHeteConditionCSAccess().getRule();
	}
	
	//FQN:
	//	(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*;
	public FQNElements getFQNAccess() {
		return pFQN;
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	// Model ContextCS:
	//	ownedExpression=ExpCS;
	public EssentialOCLGrammarAccess.ModelElements getModelAccess() {
		return gaEssentialOCL.getModelAccess();
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLReservedKeyword:
	//	'and' | 'and2' | 'else' | 'endif' | 'if' | 'implies' | 'implies2' | 'in' | 'let' | 'not' | 'not2' | 'or' | 'or2' |
	//	'then' | 'xor' | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return gaEssentialOCL.getEssentialOCLReservedKeywordAccess();
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnaryOperatorName:
	//	'-' | 'not' | 'not2';
	public EssentialOCLGrammarAccess.EssentialOCLUnaryOperatorNameElements getEssentialOCLUnaryOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnaryOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLUnaryOperatorNameRule() {
		return getEssentialOCLUnaryOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLInfixOperatorName:
	//	'*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'and2' | 'implies' | 'implies2' | 'or' | 'or2'
	//	| 'xor' | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLInfixOperatorNameElements getEssentialOCLInfixOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLInfixOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLInfixOperatorNameRule() {
		return getEssentialOCLInfixOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLNavigationOperatorName:
	//	'.' | '->' | '?.' | '?->';
	public EssentialOCLGrammarAccess.EssentialOCLNavigationOperatorNameElements getEssentialOCLNavigationOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLNavigationOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLNavigationOperatorNameRule() {
		return getEssentialOCLNavigationOperatorNameAccess().getRule();
	}
	
	//BinaryOperatorName:
	//	InfixOperatorName | NavigationOperatorName;
	public EssentialOCLGrammarAccess.BinaryOperatorNameElements getBinaryOperatorNameAccess() {
		return gaEssentialOCL.getBinaryOperatorNameAccess();
	}
	
	public ParserRule getBinaryOperatorNameRule() {
		return getBinaryOperatorNameAccess().getRule();
	}
	
	//InfixOperatorName:
	//	EssentialOCLInfixOperatorName;
	public EssentialOCLGrammarAccess.InfixOperatorNameElements getInfixOperatorNameAccess() {
		return gaEssentialOCL.getInfixOperatorNameAccess();
	}
	
	public ParserRule getInfixOperatorNameRule() {
		return getInfixOperatorNameAccess().getRule();
	}
	
	//NavigationOperatorName:
	//	EssentialOCLNavigationOperatorName;
	public EssentialOCLGrammarAccess.NavigationOperatorNameElements getNavigationOperatorNameAccess() {
		return gaEssentialOCL.getNavigationOperatorNameAccess();
	}
	
	public ParserRule getNavigationOperatorNameRule() {
		return getNavigationOperatorNameAccess().getRule();
	}
	
	//UnaryOperatorName:
	//	EssentialOCLUnaryOperatorName;
	public EssentialOCLGrammarAccess.UnaryOperatorNameElements getUnaryOperatorNameAccess() {
		return gaEssentialOCL.getUnaryOperatorNameAccess();
	}
	
	public ParserRule getUnaryOperatorNameRule() {
		return getUnaryOperatorNameAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Names
	//
	////---------------------------------------------------------------------
	//
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnrestrictedName:
	//	Identifier;
	public EssentialOCLGrammarAccess.EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnrestrictedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}
	
	//UnrestrictedName:
	//	EssentialOCLUnrestrictedName;
	public EssentialOCLGrammarAccess.UnrestrictedNameElements getUnrestrictedNameAccess() {
		return gaEssentialOCL.getUnrestrictedNameAccess();
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnreservedName:
	//	UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | 'Map' | 'Tuple';
	public EssentialOCLGrammarAccess.EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnreservedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}
	
	//UnreservedName:
	//	EssentialOCLUnreservedName;
	public EssentialOCLGrammarAccess.UnreservedNameElements getUnreservedNameAccess() {
		return gaEssentialOCL.getUnreservedNameAccess();
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}
	
	//URIPathNameCS base::PathNameCS:
	//	ownedPathElements+=URIFirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.URIPathNameCSElements getURIPathNameCSAccess() {
		return gaEssentialOCL.getURIPathNameCSAccess();
	}
	
	public ParserRule getURIPathNameCSRule() {
		return getURIPathNameCSAccess().getRule();
	}
	
	//URIFirstPathElementCS base::PathElementCS:
	//	referredElement=[pivot::NamedElement|UnrestrictedName] | {base::PathElementWithURICS}
	//	referredElement=[pivot::Namespace|URI];
	public EssentialOCLGrammarAccess.URIFirstPathElementCSElements getURIFirstPathElementCSAccess() {
		return gaEssentialOCL.getURIFirstPathElementCSAccess();
	}
	
	public ParserRule getURIFirstPathElementCSRule() {
		return getURIFirstPathElementCSAccess().getRule();
	}
	
	//SimplePathNameCS base::PathNameCS:
	//	ownedPathElements+=FirstPathElementCS;
	public EssentialOCLGrammarAccess.SimplePathNameCSElements getSimplePathNameCSAccess() {
		return gaEssentialOCL.getSimplePathNameCSAccess();
	}
	
	public ParserRule getSimplePathNameCSRule() {
		return getSimplePathNameCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Types
	//
	////---------------------------------------------------------------------
	// PrimitiveTypeIdentifier:
	//	'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' | 'OclAny' | 'OclInvalid' | 'OclVoid';
	public EssentialOCLGrammarAccess.PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return gaEssentialOCL.getPrimitiveTypeIdentifierAccess();
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}
	
	//PrimitiveTypeCS base::PrimitiveTypeRefCS:
	//	name=PrimitiveTypeIdentifier;
	public EssentialOCLGrammarAccess.PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return gaEssentialOCL.getPrimitiveTypeCSAccess();
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}
	
	//CollectionTypeIdentifier:
	//	'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet';
	public EssentialOCLGrammarAccess.CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return gaEssentialOCL.getCollectionTypeIdentifierAccess();
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}
	
	//CollectionTypeCS:
	//	name=CollectionTypeIdentifier ('(' ownedType=TypeExpWithoutMultiplicityCS ownedCollectionMultiplicity=MultiplicityCS?
	//	')')?;
	public EssentialOCLGrammarAccess.CollectionTypeCSElements getCollectionTypeCSAccess() {
		return gaEssentialOCL.getCollectionTypeCSAccess();
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}
	
	//MapTypeCS:
	//	name='Map' ('(' ownedKeyType=TypeExpCS ',' ownedValueType=TypeExpCS ')')?;
	public EssentialOCLGrammarAccess.MapTypeCSElements getMapTypeCSAccess() {
		return gaEssentialOCL.getMapTypeCSAccess();
	}
	
	public ParserRule getMapTypeCSRule() {
		return getMapTypeCSAccess().getRule();
	}
	
	//TupleTypeCS base::TupleTypeCS:
	//	name='Tuple' ('(' (ownedParts+=TuplePartCS (',' ownedParts+=TuplePartCS)*)? ')')?;
	public EssentialOCLGrammarAccess.TupleTypeCSElements getTupleTypeCSAccess() {
		return gaEssentialOCL.getTupleTypeCSAccess();
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}
	
	//TuplePartCS base::TuplePartCS:
	//	name=UnrestrictedName ':' ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.TuplePartCSElements getTuplePartCSAccess() {
		return gaEssentialOCL.getTuplePartCSAccess();
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Literals
	//
	////---------------------------------------------------------------------
	// CollectionLiteralExpCS:
	//	ownedType=CollectionTypeCS '{' (ownedParts+=CollectionLiteralPartCS (',' ownedParts+=CollectionLiteralPartCS)*)? '}';
	public EssentialOCLGrammarAccess.CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return gaEssentialOCL.getCollectionLiteralExpCSAccess();
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}
	
	//CollectionLiteralPartCS:
	//	ownedExpression=ExpCS ('..' ownedLastExpression=ExpCS)? | ownedExpression=PatternExpCS;
	public EssentialOCLGrammarAccess.CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return gaEssentialOCL.getCollectionLiteralPartCSAccess();
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}
	
	//CollectionPatternCS:
	//	ownedType=CollectionTypeCS '{' (ownedParts+=PatternExpCS (',' ownedParts+=PatternExpCS)* ('++'
	//	restVariableName=Identifier))? '}';
	public EssentialOCLGrammarAccess.CollectionPatternCSElements getCollectionPatternCSAccess() {
		return gaEssentialOCL.getCollectionPatternCSAccess();
	}
	
	public ParserRule getCollectionPatternCSRule() {
		return getCollectionPatternCSAccess().getRule();
	}
	
	//ShadowPartCS:
	//	referredProperty=[pivot::Property|UnrestrictedName] '=' ownedInitExpression=(ExpCS | PatternExpCS) |
	//	ownedInitExpression=StringLiteralExpCS;
	public EssentialOCLGrammarAccess.ShadowPartCSElements getShadowPartCSAccess() {
		return gaEssentialOCL.getShadowPartCSAccess();
	}
	
	public ParserRule getShadowPartCSRule() {
		return getShadowPartCSAccess().getRule();
	}
	
	//PatternExpCS:
	//	patternVariableName=UnrestrictedName? ':' ownedPatternType=TypeExpCS;
	public EssentialOCLGrammarAccess.PatternExpCSElements getPatternExpCSAccess() {
		return gaEssentialOCL.getPatternExpCSAccess();
	}
	
	public ParserRule getPatternExpCSRule() {
		return getPatternExpCSAccess().getRule();
	}
	
	//LambdaLiteralExpCS:
	//	'Lambda' '{' ownedExpressionCS=ExpCS '}';
	public EssentialOCLGrammarAccess.LambdaLiteralExpCSElements getLambdaLiteralExpCSAccess() {
		return gaEssentialOCL.getLambdaLiteralExpCSAccess();
	}
	
	public ParserRule getLambdaLiteralExpCSRule() {
		return getLambdaLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralExpCS:
	//	ownedType=MapTypeCS '{' (ownedParts+=MapLiteralPartCS (',' ownedParts+=MapLiteralPartCS)*)? '}';
	public EssentialOCLGrammarAccess.MapLiteralExpCSElements getMapLiteralExpCSAccess() {
		return gaEssentialOCL.getMapLiteralExpCSAccess();
	}
	
	public ParserRule getMapLiteralExpCSRule() {
		return getMapLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralPartCS:
	//	ownedKey=ExpCS '<-' ownedValue=ExpCS;
	public EssentialOCLGrammarAccess.MapLiteralPartCSElements getMapLiteralPartCSAccess() {
		return gaEssentialOCL.getMapLiteralPartCSAccess();
	}
	
	public ParserRule getMapLiteralPartCSRule() {
		return getMapLiteralPartCSAccess().getRule();
	}
	
	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
	//	NullLiteralExpCS;
	public EssentialOCLGrammarAccess.PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return gaEssentialOCL.getPrimitiveLiteralExpCSAccess();
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralExpCS:
	//	'Tuple' '{' ownedParts+=TupleLiteralPartCS (',' ownedParts+=TupleLiteralPartCS)* '}';
	public EssentialOCLGrammarAccess.TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return gaEssentialOCL.getTupleLiteralExpCSAccess();
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralPartCS:
	//	name=UnrestrictedName (':' ownedType=TypeExpCS)? '=' ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return gaEssentialOCL.getTupleLiteralPartCSAccess();
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}
	
	//NumberLiteralExpCS:
	//	symbol=NUMBER_LITERAL;
	public EssentialOCLGrammarAccess.NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return gaEssentialOCL.getNumberLiteralExpCSAccess();
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}
	
	//StringLiteralExpCS:
	//	segments+=StringLiteral+;
	public EssentialOCLGrammarAccess.StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return gaEssentialOCL.getStringLiteralExpCSAccess();
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}
	
	//BooleanLiteralExpCS:
	//	symbol='true' | symbol='false';
	public EssentialOCLGrammarAccess.BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return gaEssentialOCL.getBooleanLiteralExpCSAccess();
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}
	
	//UnlimitedNaturalLiteralExpCS:
	//	{UnlimitedNaturalLiteralExpCS} '*';
	public EssentialOCLGrammarAccess.UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return gaEssentialOCL.getUnlimitedNaturalLiteralExpCSAccess();
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}
	
	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} 'invalid';
	public EssentialOCLGrammarAccess.InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return gaEssentialOCL.getInvalidLiteralExpCSAccess();
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}
	
	//NullLiteralExpCS:
	//	{NullLiteralExpCS} 'null';
	public EssentialOCLGrammarAccess.NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return gaEssentialOCL.getNullLiteralExpCSAccess();
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}
	
	//TypeLiteralCS base::TypedRefCS:
	//	PrimitiveTypeCS | CollectionTypeCS | MapTypeCS | TupleTypeCS;
	public EssentialOCLGrammarAccess.TypeLiteralCSElements getTypeLiteralCSAccess() {
		return gaEssentialOCL.getTypeLiteralCSAccess();
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}
	
	//TypeLiteralWithMultiplicityCS base::TypedRefCS:
	//	TypeLiteralCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeLiteralWithMultiplicityCSElements getTypeLiteralWithMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeLiteralWithMultiplicityCSAccess();
	}
	
	public ParserRule getTypeLiteralWithMultiplicityCSRule() {
		return getTypeLiteralWithMultiplicityCSAccess().getRule();
	}
	
	//TypeLiteralExpCS:
	//	ownedType=TypeLiteralWithMultiplicityCS;
	public EssentialOCLGrammarAccess.TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return gaEssentialOCL.getTypeLiteralExpCSAccess();
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}
	
	//TypeNameExpCS:
	//	ownedPathName=PathNameCS (ownedCurlyBracketedClause=CurlyBracketedClauseCS ('{' ownedPatternGuard=ExpCS '}')?)?;
	public EssentialOCLGrammarAccess.TypeNameExpCSElements getTypeNameExpCSAccess() {
		return gaEssentialOCL.getTypeNameExpCSAccess();
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}
	
	//TypeExpWithoutMultiplicityCS base::TypedRefCS:
	//	TypeNameExpCS | TypeLiteralCS | CollectionPatternCS;
	public EssentialOCLGrammarAccess.TypeExpWithoutMultiplicityCSElements getTypeExpWithoutMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeExpWithoutMultiplicityCSAccess();
	}
	
	public ParserRule getTypeExpWithoutMultiplicityCSRule() {
		return getTypeExpWithoutMultiplicityCSAccess().getRule();
	}
	
	//TypeExpCS base::TypedRefCS:
	//	TypeExpWithoutMultiplicityCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeExpCSElements getTypeExpCSAccess() {
		return gaEssentialOCL.getTypeExpCSAccess();
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Expressions
	//
	////---------------------------------------------------------------------
	//
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	//
	////  that let is right associative, whereas infix operators are left associative.
	//
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	// // is
	//
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	//
	///* An expression elaborates a prefixed expression with zero or more binary operator and expression suffixes.
	// * An optionally prefixed let expression is permitted except when suffixed with further expressions.*/
	//ExpCS:
	//	PrefixedPrimaryExpCS ({InfixExpCS.ownedLeft=current} name=BinaryOperatorName ownedRight=ExpCS)? | PrefixedLetExpCS;
	public EssentialOCLGrammarAccess.ExpCSElements getExpCSAccess() {
		return gaEssentialOCL.getExpCSAccess();
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}
	
	///* A prefixed let expression elaborates a let expression with zero or more unary prefix operators. */ PrefixedLetExpCS
	//ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedLetExpCS | LetExpCS;
	public EssentialOCLGrammarAccess.PrefixedLetExpCSElements getPrefixedLetExpCSAccess() {
		return gaEssentialOCL.getPrefixedLetExpCSAccess();
	}
	
	public ParserRule getPrefixedLetExpCSRule() {
		return getPrefixedLetExpCSAccess().getRule();
	}
	
	///* A prefixed primary expression elaborates a primary expression with zero or more unary prefix operators. */
	//PrefixedPrimaryExpCS ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedPrimaryExpCS | PrimaryExpCS;
	public EssentialOCLGrammarAccess.PrefixedPrimaryExpCSElements getPrefixedPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrefixedPrimaryExpCSAccess();
	}
	
	public ParserRule getPrefixedPrimaryExpCSRule() {
		return getPrefixedPrimaryExpCSAccess().getRule();
	}
	
	///* A primary expression identifies the basic expressions from which more complex expressions may be constructed. */
	//PrimaryExpCS ExpCS:
	//	NestedExpCS | IfExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS | MapLiteralExpCS |
	//	CollectionLiteralExpCS | LambdaLiteralExpCS | TypeLiteralExpCS | NameExpCS;
	public EssentialOCLGrammarAccess.PrimaryExpCSElements getPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrimaryExpCSAccess();
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}
	
	///* A name expression is a generalised rule for expressions that start with a name and which may be followed by square, round or
	// * curly bracket clauses and optionally an @pre as well.*/
	//NameExpCS:
	//	ownedPathName=PathNameCS ownedSquareBracketedClauses+=SquareBracketedClauseCS*
	//	ownedRoundBracketedClause=RoundBracketedClauseCS? ownedCurlyBracketedClause=CurlyBracketedClauseCS? (isPre?='@'
	//	'pre')?;
	public EssentialOCLGrammarAccess.NameExpCSElements getNameExpCSAccess() {
		return gaEssentialOCL.getNameExpCSAccess();
	}
	
	public ParserRule getNameExpCSRule() {
		return getNameExpCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for the literal arguments of collections, maps, tuples and shadows.*/
	//CurlyBracketedClauseCS:
	//	{CurlyBracketedClauseCS} '{' (ownedParts+=ShadowPartCS (',' ownedParts+=ShadowPartCS)*)? '}';
	public EssentialOCLGrammarAccess.CurlyBracketedClauseCSElements getCurlyBracketedClauseCSAccess() {
		return gaEssentialOCL.getCurlyBracketedClauseCSAccess();
	}
	
	public ParserRule getCurlyBracketedClauseCSRule() {
		return getCurlyBracketedClauseCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for template specialisations and operations arguments.*/
	//RoundBracketedClauseCS:
	//	{RoundBracketedClauseCS} '(' (ownedArguments+=NavigatingArgCS ownedArguments+=(NavigatingCommaArgCS |
	//	NavigatingSemiArgCS | NavigatingBarArgCS)*)? ')';
	public EssentialOCLGrammarAccess.RoundBracketedClauseCSElements getRoundBracketedClauseCSAccess() {
		return gaEssentialOCL.getRoundBracketedClauseCSAccess();
	}
	
	public ParserRule getRoundBracketedClauseCSRule() {
		return getRoundBracketedClauseCSAccess().getRule();
	}
	
	///* A square bracket clause is a generalized rule for association class qualifiers and roles.*/ SquareBracketedClauseCS:
	//	'[' ownedTerms+=ExpCS (',' ownedTerms+=ExpCS)* ']';
	public EssentialOCLGrammarAccess.SquareBracketedClauseCSElements getSquareBracketedClauseCSAccess() {
		return gaEssentialOCL.getSquareBracketedClauseCSAccess();
	}
	
	public ParserRule getSquareBracketedClauseCSRule() {
		return getSquareBracketedClauseCSAccess().getRule();
	}
	
	///* A navigating argument is a generalized rule for the first argument in a round bracket clause. This is typically the first operation
	// * parameter or an iterator. */
	//NavigatingArgCS:
	//	ownedNameExpression=NavigatingArgExpCS ('<-' ownedCoIterator=CoIteratorVariableCS ('=' ownedInitExpression=ExpCS)? |
	//	':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('=' ownedInitExpression=ExpCS)? | (':'
	//	ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in' ownedInitExpression=ExpCS)? | ':'
	//	ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.NavigatingArgCSElements getNavigatingArgCSAccess() {
		return gaEssentialOCL.getNavigatingArgCSAccess();
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating bar argument is a generalized rule for a bar-prefixed argument in a round bracket clause. This is typically the body of an iteration. */
	//NavigatingBarArgCS NavigatingArgCS:
	//	prefix='|' ownedNameExpression=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return gaEssentialOCL.getNavigatingBarArgCSAccess();
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating comma argument is a generalized rule for non-first argument in a round bracket clause. These are typically non-first operation
	// * parameters or a second iterator. */
	//NavigatingCommaArgCS NavigatingArgCS:
	//	prefix=',' ownedNameExpression=NavigatingArgExpCS ('<-' ownedCoIterator=CoIteratorVariableCS ('='
	//	ownedInitExpression=ExpCS)? | ':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('='
	//	ownedInitExpression=ExpCS)? | (':' ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in'
	//	ownedInitExpression=ExpCS)?;
	public EssentialOCLGrammarAccess.NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return gaEssentialOCL.getNavigatingCommaArgCSAccess();
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating semi argument is a generalized rule for a semicolon prefixed argument in a round bracket clause. This is typically an iterate accumulator. */
	//NavigatingSemiArgCS NavigatingArgCS:
	//	prefix=';' ownedNameExpression=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return gaEssentialOCL.getNavigatingSemiArgCSAccess();
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	// NavigatingArgExpCS ExpCS:
	//	ExpCS //	'?'	-- defined by Complete OCL
	//;
	public EssentialOCLGrammarAccess.NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return gaEssentialOCL.getNavigatingArgExpCSAccess();
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}
	
	//CoIteratorVariableCS VariableCS:
	//	name=UnrestrictedName (':' ownedType=TypeExpCS)?;
	public EssentialOCLGrammarAccess.CoIteratorVariableCSElements getCoIteratorVariableCSAccess() {
		return gaEssentialOCL.getCoIteratorVariableCSAccess();
	}
	
	public ParserRule getCoIteratorVariableCSRule() {
		return getCoIteratorVariableCSAccess().getRule();
	}
	
	//IfExpCS:
	//	'if' ownedCondition=(ExpCS | PatternExpCS) 'then' ownedThenExpression=ExpCS //	ifThenExpressions+=IfThenExpCS
	//
	//	ownedIfThenExpressions+=ElseIfThenExpCS* 'else' ownedElseExpression=ExpCS 'endif';
	public EssentialOCLGrammarAccess.IfExpCSElements getIfExpCSAccess() {
		return gaEssentialOCL.getIfExpCSAccess();
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}
	
	////IfThenExpCS returns IfThenExpCS:
	// //	'if' condition=ExpCS
	// //	'then' thenExpression=ExpCS
	// //;
	// ElseIfThenExpCS
	//IfThenExpCS:
	//	'elseif' ownedCondition=ExpCS 'then' ownedThenExpression=ExpCS;
	public EssentialOCLGrammarAccess.ElseIfThenExpCSElements getElseIfThenExpCSAccess() {
		return gaEssentialOCL.getElseIfThenExpCSAccess();
	}
	
	public ParserRule getElseIfThenExpCSRule() {
		return getElseIfThenExpCSAccess().getRule();
	}
	
	//LetExpCS:
	//	'let' ownedVariables+=LetVariableCS (',' ownedVariables+=LetVariableCS)* 'in' ownedInExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetExpCSElements getLetExpCSAccess() {
		return gaEssentialOCL.getLetExpCSAccess();
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}
	
	//LetVariableCS:
	//	name=UnrestrictedName ownedRoundBracketedClause=RoundBracketedClauseCS? (':' ownedType=TypeExpCS)? '='
	//	ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetVariableCSElements getLetVariableCSAccess() {
		return gaEssentialOCL.getLetVariableCSAccess();
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}
	
	//NestedExpCS:
	//	'(' ownedExpression=ExpCS ')';
	public EssentialOCLGrammarAccess.NestedExpCSElements getNestedExpCSAccess() {
		return gaEssentialOCL.getNestedExpCSAccess();
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}
	
	//SelfExpCS:
	//	{SelfExpCS} 'self';
	public EssentialOCLGrammarAccess.SelfExpCSElements getSelfExpCSAccess() {
		return gaEssentialOCL.getSelfExpCSAccess();
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}
	
	//MultiplicityBoundsCS:
	//	lowerBound=LOWER ('..' upperBound=UPPER)?;
	public BaseGrammarAccess.MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return gaBase.getMultiplicityBoundsCSAccess();
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}
	
	//MultiplicityCS:
	//	'[' (MultiplicityBoundsCS | MultiplicityStringCS) ('|?' | isNullFree?='|1')? ']';
	public BaseGrammarAccess.MultiplicityCSElements getMultiplicityCSAccess() {
		return gaBase.getMultiplicityCSAccess();
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}
	
	//MultiplicityStringCS:
	//	stringBounds=('*' | '+' | '?');
	public BaseGrammarAccess.MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return gaBase.getMultiplicityStringCSAccess();
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}
	
	//PathNameCS:
	//	ownedPathElements+=FirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public BaseGrammarAccess.PathNameCSElements getPathNameCSAccess() {
		return gaBase.getPathNameCSAccess();
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}
	
	//FirstPathElementCS PathElementCS:
	//	referredElement=[pivot::NamedElement|super::UnrestrictedName];
	public BaseGrammarAccess.FirstPathElementCSElements getFirstPathElementCSAccess() {
		return gaBase.getFirstPathElementCSAccess();
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}
	
	//NextPathElementCS PathElementCS:
	//	referredElement=[pivot::NamedElement|super::UnreservedName];
	public BaseGrammarAccess.NextPathElementCSElements getNextPathElementCSAccess() {
		return gaBase.getNextPathElementCSAccess();
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}
	
	//TemplateBindingCS:
	//	ownedSubstitutions+=TemplateParameterSubstitutionCS (',' ownedSubstitutions+=TemplateParameterSubstitutionCS)*
	//	ownedMultiplicity=MultiplicityCS?;
	public BaseGrammarAccess.TemplateBindingCSElements getTemplateBindingCSAccess() {
		return gaBase.getTemplateBindingCSAccess();
	}
	
	public ParserRule getTemplateBindingCSRule() {
		return getTemplateBindingCSAccess().getRule();
	}
	
	//TemplateParameterSubstitutionCS:
	//	ownedActualParameter=TypeRefCS;
	public BaseGrammarAccess.TemplateParameterSubstitutionCSElements getTemplateParameterSubstitutionCSAccess() {
		return gaBase.getTemplateParameterSubstitutionCSAccess();
	}
	
	public ParserRule getTemplateParameterSubstitutionCSRule() {
		return getTemplateParameterSubstitutionCSAccess().getRule();
	}
	
	//TemplateSignatureCS:
	//	'(' ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* ')';
	public BaseGrammarAccess.TemplateSignatureCSElements getTemplateSignatureCSAccess() {
		return gaBase.getTemplateSignatureCSAccess();
	}
	
	public ParserRule getTemplateSignatureCSRule() {
		return getTemplateSignatureCSAccess().getRule();
	}
	
	//TypeParameterCS:
	//	name=super::UnrestrictedName ('extends' ownedExtends+=TypedRefCS ('&&' ownedExtends+=TypedRefCS)*)?;
	public BaseGrammarAccess.TypeParameterCSElements getTypeParameterCSAccess() {
		return gaBase.getTypeParameterCSAccess();
	}
	
	public ParserRule getTypeParameterCSRule() {
		return getTypeParameterCSAccess().getRule();
	}
	
	//TypeRefCS:
	//	TypedRefCS | WildcardTypeRefCS;
	public BaseGrammarAccess.TypeRefCSElements getTypeRefCSAccess() {
		return gaBase.getTypeRefCSAccess();
	}
	
	public ParserRule getTypeRefCSRule() {
		return getTypeRefCSAccess().getRule();
	}
	
	//TypedRefCS:
	//	TypedTypeRefCS;
	public BaseGrammarAccess.TypedRefCSElements getTypedRefCSAccess() {
		return gaBase.getTypedRefCSAccess();
	}
	
	public ParserRule getTypedRefCSRule() {
		return getTypedRefCSAccess().getRule();
	}
	
	//TypedTypeRefCS:
	//	ownedPathName=PathNameCS ('(' ownedBinding=TemplateBindingCS ')')?;
	public BaseGrammarAccess.TypedTypeRefCSElements getTypedTypeRefCSAccess() {
		return gaBase.getTypedTypeRefCSAccess();
	}
	
	public ParserRule getTypedTypeRefCSRule() {
		return getTypedTypeRefCSAccess().getRule();
	}
	
	//WildcardTypeRefCS:
	//	{WildcardTypeRefCS} '?' ('extends' ownedExtends=TypedRefCS)?;
	public BaseGrammarAccess.WildcardTypeRefCSElements getWildcardTypeRefCSAccess() {
		return gaBase.getWildcardTypeRefCSAccess();
	}
	
	public ParserRule getWildcardTypeRefCSRule() {
		return getWildcardTypeRefCSAccess().getRule();
	}
	
	//ID:
	//	SIMPLE_ID | ESCAPED_ID;
	public BaseGrammarAccess.IDElements getIDAccess() {
		return gaBase.getIDAccess();
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}
	
	//Identifier:
	//	ID;
	public BaseGrammarAccess.IdentifierElements getIdentifierAccess() {
		return gaBase.getIdentifierAccess();
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	///* A lowerbounded integer is used to define the lowerbound of a collection multiplicity. The value may not be the unlimited value. */
	//LOWER ecore::EInt:
	//	INT;
	public BaseGrammarAccess.LOWERElements getLOWERAccess() {
		return gaBase.getLOWERAccess();
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}
	
	///* A number may be an integer or floating point value. The declaration here appears to be that for just an integer. This is to avoid
	// * lookahead conflicts in simple lexers between a dot within a floating point number and the dot-dot in a CollectionLiteralPartCS. A
	// * practical implementation should give high priority to a successful parse of INT ('.' INT)? (('e' | 'E') ('+' | '-')? INT)? than
	// * to the unsuccessful partial parse of INT '..'. The type of the INT terminal is String to allow the floating point syntax to be used.
	// */
	//NUMBER_LITERAL BigNumber:
	//	INT;
	public BaseGrammarAccess.NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return gaBase.getNUMBER_LITERALAccess();
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}
	
	//// EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;
	// StringLiteral:
	//	SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaBase.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	///* An upperbounded integer is used to define the upperbound of a collection multiplicity. The value may be the unlimited value. */
	//UPPER ecore::EInt:
	//	INT | '*';
	public BaseGrammarAccess.UPPERElements getUPPERAccess() {
		return gaBase.getUPPERAccess();
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}
	
	//URI:
	//	SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.URIElements getURIAccess() {
		return gaBase.getURIAccess();
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}
	
	//terminal fragment ESCAPED_CHARACTER:
	//	'\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\');
	public TerminalRule getESCAPED_CHARACTERRule() {
		return gaBase.getESCAPED_CHARACTERRule();
	}
	
	//terminal fragment LETTER_CHARACTER:
	//	'a'..'z' | 'A'..'Z' | '_';
	public TerminalRule getLETTER_CHARACTERRule() {
		return gaBase.getLETTER_CHARACTERRule();
	}
	
	//terminal DOUBLE_QUOTED_STRING:
	//	'"' (ESCAPED_CHARACTER | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return gaBase.getDOUBLE_QUOTED_STRINGRule();
	}
	
	//terminal SINGLE_QUOTED_STRING:
	//	"'" (ESCAPED_CHARACTER | !('\\' | "'"))* "'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return gaBase.getSINGLE_QUOTED_STRINGRule();
	}
	
	//terminal ML_SINGLE_QUOTED_STRING:
	//	"/'"->"'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return gaBase.getML_SINGLE_QUOTED_STRINGRule();
	}
	
	//terminal SIMPLE_ID:
	//	LETTER_CHARACTER (LETTER_CHARACTER | '0'..'9')*;
	public TerminalRule getSIMPLE_IDRule() {
		return gaBase.getSIMPLE_IDRule();
	}
	
	//terminal ESCAPED_ID:
	//	"_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return gaBase.getESCAPED_IDRule();
	}
	
	//terminal INT:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaBase.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaBase.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaBase.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaBase.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaBase.getANY_OTHERRule();
	}
}
